// The standard library

/// Types
const sizeof(u64) 8 end
const sizeof(u32) 4 end
const sizeof(u16) 2 end
const sizeof(u8)  1 end

const sizeof(int)  sizeof(u64) end
const sizeof(ptr)  sizeof(u64) end
const sizeof(bool) sizeof(u8)  end

const sizeof(str)  sizeof(int) sizeof(ptr) add end

/// Pointer operations
inline proc ptr+ :: ptr int -> ptr do cast(ptr) add end
inline proc ptr- :: ptr int -> ptr do cast(ptr) add end

/// Mathematical operations
macro +  cast(int) swap cast(int)      add    end
macro -  cast(int) swap cast(int) swap sub    end
macro *  cast(int) swap cast(int)      mul    end
macro /% cast(int) swap cast(int) swap divmod end
macro /  /%      drop end
macro %  /% swap drop end

macro div divmod      drop end
macro mod divmod swap drop end

macro idiv idivmod      drop end
macro imod idivmod swap drop end

/// Bitwise operations
macro << cast(int) swap cast(int) swap shl end
macro >> cast(int) swap cast(int) swap shr end
macro &  cast(int) swap cast(int) swap and end
macro |  cast(int) swap cast(int) swap or  end
macro ^  cast(int) swap cast(int) swap xor end
macro ~  cast(int)                     not end

/// Logical operations
macro > cast(int) swap cast(int) lt end
macro < cast(int) swap cast(int) gt end
macro = cast(int) swap cast(int) eq end

macro && cast(bool) swap cast(bool) land end
macro || cast(bool) swap cast(bool) lor  end
macro !  cast(bool)                 lnot end

inline proc lnot :: bool -> bool do
  cast(int) 1 swap sub cast(bool)
end

inline proc land :: bool bool -> bool do
  cast(int) swap cast(int) and cast(bool)
end

inline proc lor :: bool bool -> bool do
  cast(int) swap cast(int) or cast(bool)
end

inline proc lxor :: bool bool -> bool do
  2dup land lnot rot rot lor land
end

/// Memory

macro !8  write8  end
macro !16 write16 end
macro !32 write32 end
macro !64 write64 end

macro @8  read8  end
macro @16 read16 end
macro @32 read32 end
macro @64 read64 end

/// Syscalls
unsafe inline proc syscall0 :: int -> int do
  asm
    pop rax
    syscall
    push rax
  end
end

unsafe inline proc syscall1 :: a int -> int do
  asm
    pop rax
    pop rdi
    syscall
    push rax
  end
end

unsafe inline proc syscall2 :: a b int -> int do
  asm
    pop rax
    pop rdi
    pop rsi
    syscall
    push rax
  end
end

unsafe inline proc syscall3 :: a b c int -> int do
  asm
    pop rax
    pop rdi
    pop rsi
    pop rdx
    syscall
    push rax
  end
end

unsafe inline proc syscall4 :: a b c d int -> int do
  asm
    pop rax
    pop rdi
    pop rsi
    pop rdx
    pop r10
    syscall
    push rax
  end
end

unsafe inline proc syscall5 :: a b c d e int -> int do
  asm
    pop rax
    pop rdi
    pop rsi
    pop rdx
    pop r10
    pop r8
    syscall
    push rax
  end
end

unsafe inline proc syscall6 :: a b c d e f int -> int do
  asm
    pop rax
    pop rdi
    pop rsi
    pop rdx
    pop r10
    pop r8
    pop r9
    syscall
    push rax
  end
end

/// stdio

// TODO: Local memories for procedures
memory _putu_buffer 32 end

proc putu :: int do
  dup 0 eq if
    "0" puts drop
  else
    31 swap while dup 0 gt do
      10 divmod '0' add
      rot _putu_buffer over ptr+
      rot swap write8
      1 sub
      swap
    end
    drop
    _putu_buffer over ptr+
    swap 32 swap sub
    swap puts

    // TODO: Local memories for procedures
    0 while dup 32 lt do
      0 over _putu_buffer swap ptr+ write64
      8 add
    end drop
  end
end

proc puti :: int do
  dup 0 lt if
    "-" puts
    not 1 add putu
  else putu end
end

proc is-digit :: int -> bool do
  dup  1 add '0' gt
  over 1 sub '9' lt
  land swap drop
end

// TODO: Does not parse negative integers
proc parse-int :: int ptr -> int do
  // ptr out len inc
  swap 0 swap 0 while 2dup gt do
    // len out ptr inc ptr+inc
    swap 2swap rot 2dup ptr+
    // len inc ptr out+char
    read8
    dup is-digit if
      '0' sub swap 2swap rot add 10 mul
    else
      // len inc ptr out
      drop swap rot
    end
    // ptr out len inc
    swap 2swap swap 1 add
  end
  drop drop swap drop 10 div
end
