// The standard library

/// Types
const sizeof(u64) 8 end
const sizeof(u32) 4 end
const sizeof(u16) 2 end
const sizeof(u8)  1 end

const sizeof(int)  sizeof(u64) end
const sizeof(ptr)  sizeof(u64) end
const sizeof(bool) sizeof(u8)  end

/// Pointer operations
inline proc ptr+ :: ptr int -> ptr do cast(ptr) add end
inline proc ptr- :: ptr int -> ptr do cast(ptr) add end

/// Mathematical operations
macro div divmod      drop end
macro mod divmod swap drop end

macro idiv idivmod      drop end
macro imod idivmod swap drop end

/// Logical operations
inline proc lnot :: bool -> bool do
  cast(int) 1 swap sub cast(bool)
end

inline proc land :: bool bool -> bool do
  cast(int) swap cast(int) and cast(bool)
end

inline proc lor :: bool bool -> bool do
  cast(int) swap cast(int) or cast(bool)
end

inline proc lxor :: bool bool -> bool do
  2dup land lnot rot rot lor land
end

/// Memory
macro !8  write8  end
macro !16 write16 end
macro !32 write32 end
macro !64 write64 end

macro @8  read8  end
macro @16 read16 end
macro @32 read32 end
macro @64 read64 end

macro !int write64 end
macro !ptr write64 end

macro @int read64  end
macro @ptr read64  end

/// Strings

const Str.len     sizeof(int) offset end
const Str.data    sizeof(ptr) offset end
const sizeof(Str) reset end

proc is-digit :: int -> bool do
  dup  1 add '0' gt
  over 1 sub '9' lt
  land swap drop
end

proc parse-uint :: int ptr -> int do
  let len data do
    0 0 // out inc
    while dup len lt do
      dup cast(ptr) data add read8
      dup is-digit if
        '0' sub rot 10 mul add swap
      else drop end

      1 add
    end drop
  end
end

proc parse-int :: int ptr -> int do
  dup read8 '-' eq if
    1 ptr+ swap 1 sub swap
    parse-uint not 1 add
  else parse-uint end
end

/// Random
// TODO: Move to a separate library

// Using the https://en.wikipedia.org/wiki/Linear_congruential_generator algorithm
memory lcg_mod sizeof(int) end
const LCG_MULTIPLIER 6364136223846793005 end
const LCG_INCREMENT  1442695040888963407 end

proc lcg -> int do
  lcg_mod read64
  LCG_MULTIPLIER mul LCG_INCREMENT add
  dup lcg_init
end

inline proc lcg_init :: int do
  lcg_mod write64
end
// TODO: Add more algorithms and random-related functions

/// stdio
// TODO: Move to a separate library

// TODO: Local memories for procedures
memory _putu_buffer 32 end

proc putu :: int do
  dup 0 eq if
    "0" puts drop
  else
    31 swap while dup 0 gt do
      10 divmod '0' add
      rot _putu_buffer over ptr+
      rot swap write8
      1 sub
      swap
    end
    drop
    _putu_buffer over ptr+
    swap 32 swap sub
    swap puts

    // TODO: Local memories for procedures
    0 while dup 32 lt do
      0 over _putu_buffer swap ptr+ write64
      8 add
    end drop
  end
end

proc puti :: int do
  dup 0 lt if
    "-" puts
    not 1 add putu
  else putu end
end
