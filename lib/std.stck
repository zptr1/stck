// The standard library

/// Types
const sizeof(u64) 8 end
const sizeof(u32) 4 end
const sizeof(u16) 2 end
const sizeof(u8)  1 end

const sizeof(int)  sizeof(u64) end
const sizeof(ptr)  sizeof(u64) end
const sizeof(bool) sizeof(u8)  end

const sizeof(str)  sizeof(int) sizeof(ptr) add end

/// Pointer operations
macro ptr+ + cast(ptr) end
macro ptr- - cast(ptr) end

/// Mathematical operations
macro +  cast(int) swap cast(int)      add    end
macro -  cast(int) swap cast(int) swap sub    end
macro *  cast(int) swap cast(int)      mul    end
macro /% cast(int) swap cast(int) swap divmod end
macro /  /%      drop end
macro %  /% swap drop end

macro div divmod      drop end
macro mod divmod swap drop end

/// Bitwise operations
macro << cast(int) swap cast(int) swap shl end
macro >> cast(int) swap cast(int) swap shr end
macro &  cast(int) swap cast(int) swap and end
macro |  cast(int) swap cast(int) swap or  end
macro ^  cast(int) swap cast(int) swap xor end
macro ~  cast(int)                     not end

/// Logical operations
macro > cast(int) swap cast(int) lt end
macro < cast(int) swap cast(int) gt end
macro = cast(int) swap cast(int) eq end

macro && cast(bool) swap cast(bool) land end
macro || cast(bool) swap cast(bool) lor  end
macro !  cast(bool)                 lnot end

inline proc lnot :: bool -> bool do
  cast(int) 1 swap sub cast(bool)
end

inline proc land :: bool bool -> bool do
  cast(int) swap cast(int) and cast(bool)
end

inline proc lor :: bool bool -> bool do
  cast(int) swap cast(int) or cast(bool)
end

inline proc lxor :: bool bool -> bool do
  dup2 land lnot rot rot lor land
end

/// Memory

macro !8  write8  end
macro !16 write16 end
macro !32 write32 end
macro !64 write64 end

macro @8  read8  end
macro @16 read16 end
macro @32 read32 end
macro @64 read64 end

proc write(int) :: int ptr do
  swap sizeof(int) while dup 0 gt do
    1 sub
    // ptr int (inc=3..0) ((int >> 8*inc) & 255)
    dup2 3 swap sub 8 mul shr 255 and
    // int ptr (inc=3..0) ((int >> 8*inc) & 255) (ptr+inc)
    rot swap2 dup2 ptr+ swap swap2 rot write8
    // ptr int (inc=3..0)
    rot swap
  end drop drop drop
end

proc read(int) :: ptr -> int do
  // ptr int inc
  0 0 while dup sizeof(int) lt do
    // int inc ptr (read(inc+ptr))
    rot dup2 ptr+ read8
    // int ptr inc (read(inc+ptr)<<(3-inc)*8)
    rot dup 3 swap sub 8 mul rot swap shl
    // ptr inc (int|read(inc+ptr)<<(3-inc)*8)
    swap rot swap2 swap or
    // ptr int inc
    swap 1 add
  end drop swap drop
end