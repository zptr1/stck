// The standard library

/// Types
const sizeof(u64) 8 end
const sizeof(u32) 4 end
const sizeof(u16) 2 end
const sizeof(u8)  1 end

const sizeof(int)  sizeof(u64) end
const sizeof(ptr)  sizeof(u64) end
const sizeof(bool) sizeof(u8)  end

const sizeof(str)  sizeof(int) sizeof(ptr) add end

/// Pointer operations
inline proc ptr+ :: ptr int -> ptr do cast(ptr) add end
inline proc ptr- :: ptr int -> ptr do cast(ptr) add end

/// Mathematical operations
macro div divmod      drop end
macro mod divmod swap drop end

macro idiv idivmod      drop end
macro imod idivmod swap drop end

/// Logical operations
inline proc lnot :: bool -> bool do
  cast(int) 1 swap sub cast(bool)
end

inline proc land :: bool bool -> bool do
  cast(int) swap cast(int) and cast(bool)
end

inline proc lor :: bool bool -> bool do
  cast(int) swap cast(int) or cast(bool)
end

inline proc lxor :: bool bool -> bool do
  2dup land lnot rot rot lor land
end

/// Random

// Using the https://en.wikipedia.org/wiki/Linear_congruential_generator algorithm
memory lcg_mod sizeof(int) end
const LCG_MULTIPLIER 6364136223846793005 end
const LCG_INCREMENT  1442695040888963407 end

proc lcg -> int do
  lcg_mod read64
  LCG_MULTIPLIER mul LCG_INCREMENT add
  dup lcg_init
end

inline proc lcg_init :: int do
  lcg_mod write64
end
// TODO: Add more algorithms and random-related functions

/// Memory
macro !8  write8  end
macro !16 write16 end
macro !32 write32 end
macro !64 write64 end

macro @8  read8  end
macro @16 read16 end
macro @32 read32 end
macro @64 read64 end

/// stdio
// TODO: Move to a separate stdio library?

// TODO: Local memories for procedures
memory _putu_buffer 32 end

proc putu :: int do
  dup 0 eq if
    "0" puts drop
  else
    31 swap while dup 0 gt do
      10 divmod '0' add
      rot _putu_buffer over ptr+
      rot swap write8
      1 sub
      swap
    end
    drop
    _putu_buffer over ptr+
    swap 32 swap sub
    swap puts

    // TODO: Local memories for procedures
    0 while dup 32 lt do
      0 over _putu_buffer swap ptr+ write64
      8 add
    end drop
  end
end

proc puti :: int do
  dup 0 lt if
    "-" puts
    not 1 add putu
  else putu end
end

/// String operations

proc is-digit :: int -> bool do
  dup  1 add '0' gt
  over 1 sub '9' lt
  land swap drop
end

// TODO: Does not parse negative integers
proc parse-int :: int ptr -> int do
  // ptr out len inc
  swap 0 swap 0 while 2dup gt do
    // len out ptr inc ptr+inc
    swap 2swap rot 2dup ptr+
    // len inc ptr out+char
    read8
    dup is-digit if
      '0' sub swap 2swap rot add 10 mul
    else
      // len inc ptr out
      drop swap rot
    end
    // ptr out len inc
    swap 2swap swap 1 add
  end
  drop drop swap drop 10 div
end
